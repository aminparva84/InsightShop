"""Admin routes for managing fashion knowledge base and system settings."""
from flask import Blueprint, request, jsonify
from models.database import db
from models.user import User
from models.payment_log import PaymentLog
from models.order import Order
from models.sale import Sale
from models.product import Product
from models.review import Review
from models.ai_assistant_config import AiAssistantConfig
from routes.auth import require_auth
from utils.fashion_kb import FASHION_KNOWLEDGE_BASE
from utils.seasonal_events import get_upcoming_holidays, get_current_holidays_and_events
from functools import wraps
from datetime import date, datetime
import json
import os

admin_bp = Blueprint('admin', __name__)

def require_admin(f):
    """Decorator to require superadmin authentication."""
    @wraps(f)
    @require_auth
    def decorated_function(*args, **kwargs):
        user = request.current_user
        if not user.is_superadmin:
            return jsonify({'error': 'Superadmin access required'}), 403
        return f(*args, **kwargs)
    return decorated_function

@admin_bp.route('/fashion-kb', methods=['GET'])
@require_admin
def get_fashion_kb():
    """Get the fashion knowledge base."""
    try:
        return jsonify({
            'success': True,
            'data': FASHION_KNOWLEDGE_BASE
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/fashion-kb', methods=['POST'])
@require_admin
def update_fashion_kb():
    """Update the fashion knowledge base."""
    try:
        data = request.get_json()
        kb_data = data.get('data')
        
        if not kb_data:
            return jsonify({'error': 'Knowledge base data is required'}), 400
        
        # Validate structure
        required_keys = ['color_matching', 'style_advice', 'occasions', 'fabric_guide', 'dress_styles', 'styling_tips']
        if not all(key in kb_data for key in required_keys):
            return jsonify({'error': 'Invalid knowledge base structure'}), 400
        
        # Backup current KB
        kb_file = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'utils', 'fashion_kb.py')
        backup_file = kb_file + '.backup'
        
        try:
            with open(kb_file, 'r', encoding='utf-8') as f:
                current_content = f.read()
            with open(backup_file, 'w', encoding='utf-8') as f:
                f.write(current_content)
        except Exception as e:
            print(f"Warning: Could not create backup: {e}")
        
        # Generate new fashion_kb.py file (formatter includes all sections for AI; optional keys safe via .get())
        kb_content = f'''"""Fashion Knowledge Base for AI Agent - Style, Color Matching, Occasions, and Complete-the-Look."""
# This file is auto-generated by admin panel. Manual edits may be overwritten.

FASHION_KNOWLEDGE_BASE = {json.dumps(kb_data, indent=4, ensure_ascii=False)}

def get_fashion_knowledge_base_text():
    """Get the full fashion knowledge base as formatted text for AI."""
    kb = FASHION_KNOWLEDGE_BASE
    color_basics = kb.get("color_matching", {{}}).get("basics", "")
    by_color = kb.get("color_matching", {{}}).get("by_color", {{}})
    color_by_color_text = "\\n".join([f"- {{k}}: {{v}}" for k, v in by_color.items()]) if by_color else ""
    color_matching_full = color_basics + "\\n\\nBY COLOR:\\n" + color_by_color_text if color_by_color_text else color_basics
    style_advice_dict = kb.get("style_advice", {{}})
    style_keys = ["fit", "layering", "proportions", "texture_mixing", "formality_levels", "style_archetypes"]
    style_advice_text = "\\n".join([style_advice_dict.get(k, "") for k in style_keys if style_advice_dict.get(k)])
    occasions_text = "\\n".join([f"{{k.upper().replace('_', ' ')}}:\\n{{v}}" for k, v in kb.get("occasions", {{}}).items()]) if kb.get("occasions") else ""
    dress_codes_text = "\\n".join([f"- {{k.replace('_', ' ').title()}}: {{v}}" for k, v in kb.get("dress_codes", {{}}).items()]) if kb.get("dress_codes") else ""
    fabric_guide_text = "\\n".join([f"{{k.upper()}}: {{v.get('description','')}}\\nBest for: {{v.get('best_for','')}}\\nCharacteristics: {{v.get('characteristics','')}}" for k, v in (kb.get("fabric_guide") or {{}}).items()])
    fabric_pairing_text = kb.get("fabric_pairing", "") or ""
    ds = kb.get("dress_styles", {{}})
    necklines_text = "\\n".join([f"{{k.upper().replace('_', '-')}} NECKLINE:\\n{{v.get('description','')}}\\nBest for: {{v.get('best_for','')}}\\nOccasions: {{v.get('occasions','')}}" for k, v in ds.get("necklines", {{}}).items()]) if ds.get("necklines") else ""
    features_text = "\\n".join([f"{{k.upper().replace('_', '-')}} FEATURE:\\n{{v.get('description','')}}\\nBest for: {{v.get('best_for','')}}\\nOccasions: {{v.get('occasions','')}}" for k, v in ds.get("dress_features", {{}}).items()]) if ds.get("dress_features") else ""
    men_styles_text = "\\n".join([f"{{k.upper().replace('_', '-')}} STYLE:\\n{{v.get('description','')}}\\nBest for: {{v.get('best_for','')}}\\nOccasions: {{v.get('occasions','')}}" for k, v in ds.get("men_styles", {{}}).items()]) if ds.get("men_styles") else ""
    styling_tips_text = "\\n".join([kb.get("styling_tips", {{}}).get(k, "") for k in ["build_wardrobe", "accessories", "seasonal_transitions"] if kb.get("styling_tips", {{}}).get(k)])
    of = kb.get("outfit_formulas", {{}})
    of_desc = of.get("description", "")
    of_by_cat = of.get("by_primary_category", {{}})
    of_by_cat_text = "\\n".join([f"- {{k}}: {{v}}" for k, v in of_by_cat.items()]) if of_by_cat else ""
    outfit_formulas_text = (of_desc + "\\n\\nBY PRIMARY CATEGORY:\\n" + of_by_cat_text + "\\n\\n" + of.get("color_logic", "") + "\\n" + of.get("formality_logic", "") + "\\n" + of.get("season_logic", "")) if (of_desc or of_by_cat_text) else ""
    pr = kb.get("pattern_rules", {{}})
    pattern_rules_text = (pr.get("basics", "") + "\\nAVOID: " + pr.get("avoid", "")) if (pr.get("basics") or pr.get("avoid")) else ""
    recommendation_priority_text = kb.get("recommendation_priority", "") or ""
    sections = [
        ("COLOR MATCHING & COORDINATION", color_matching_full),
        ("STYLE ADVICE", style_advice_text),
        ("OCCASION-APPROPRIATE DRESSING", occasions_text),
        ("DRESS CODES", dress_codes_text),
        ("FABRIC GUIDE", fabric_guide_text),
        ("FABRIC PAIRING", fabric_pairing_text),
        ("DRESS STYLES & NECKLINES (WOMEN)", necklines_text),
        ("DRESS FEATURES (WOMEN)", features_text),
        ("MEN'S STYLES", men_styles_text),
        ("STYLING TIPS", styling_tips_text),
        ("OUTFIT FORMULAS (complete-the-look for cart/owned items)", outfit_formulas_text),
        ("PATTERN RULES", pattern_rules_text),
        ("RECOMMENDATION PRIORITY", recommendation_priority_text),
    ]
    parts = ["FASHION KNOWLEDGE BASE FOR INSIGHTSHOP AI ASSISTANT", "=" * 50]
    for title, content in sections:
        if content and str(content).strip():
            parts.append("\\n" + title + ":\\n" + str(content).strip())
    return "\\n".join(parts)

def get_color_matching_advice(color):
    """Get color matching advice for a specific color."""
    color_lower = color.lower() if color else ""
    return FASHION_KNOWLEDGE_BASE.get("color_matching", {{}}).get("by_color", {{}}).get(color_lower, "This color pairs well with neutrals like black, white, gray, and navy for a classic look.")

def get_fabric_info(fabric_name):
    """Get information about a specific fabric."""
    if not fabric_name:
        return None
    
    fabric_lower = fabric_name.lower()
    for fabric_key, fabric_info in FASHION_KNOWLEDGE_BASE.get("fabric_guide", {{}}).items():
        if fabric_key in fabric_lower or fabric_lower in fabric_key:
            return fabric_info
    return None

def get_occasion_advice(occasion):
    """Get styling advice for a specific occasion."""
    occasion_lower = occasion.lower().replace(" ", "_")
    return FASHION_KNOWLEDGE_BASE.get("occasions", {{}}).get(occasion_lower, "Choose clothing that makes you feel confident and appropriate for the setting.")

def get_outfit_formula(primary_category_or_product_name):
    """Get complete-the-look suggestion for a product type (cart/owned matching)."""
    formulas = FASHION_KNOWLEDGE_BASE.get("outfit_formulas", {{}}).get("by_primary_category", {{}})
    if not formulas:
        return None
    name_lower = (primary_category_or_product_name or "").lower()
    for category_key, advice in formulas.items():
        keywords = category_key.replace("_", " ").split()
        if any(kw in name_lower for kw in keywords):
            return advice
    return None

def get_dress_code_advice(dress_code):
    """Get advice for a dress code (e.g. black_tie, smart_casual)."""
    code_lower = (dress_code or "").lower().replace(" ", "_")
    return FASHION_KNOWLEDGE_BASE.get("dress_codes", {{}}).get(code_lower)
'''
        
        # Write new file
        with open(kb_file, 'w', encoding='utf-8') as f:
            f.write(kb_content)
        
        # Reload the module (requires app restart for full effect, but we can try)
        import importlib
        import sys
        if 'utils.fashion_kb' in sys.modules:
            importlib.reload(sys.modules['utils.fashion_kb'])
        
        return jsonify({
            'success': True,
            'message': 'Fashion knowledge base updated successfully. Please restart the application for changes to take full effect.'
        }), 200
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'Failed to update knowledge base: {str(e)}'}), 500

@admin_bp.route('/fashion-kb/color', methods=['POST'])
@require_admin
def add_color_matching():
    """Add or update color matching advice."""
    try:
        data = request.get_json()
        color = data.get('color', '').lower()
        advice = data.get('advice', '')
        
        if not color or not advice:
            return jsonify({'error': 'Color and advice are required'}), 400
        
        # This would update the KB file - for now return success
        # Full implementation would modify the FASHION_KNOWLEDGE_BASE structure
        return jsonify({
            'success': True,
            'message': f'Color matching advice for {color} updated. Use the full KB update endpoint for permanent changes.'
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/fashion-kb/fabric', methods=['POST'])
@require_admin
def add_fabric_info():
    """Add or update fabric information."""
    try:
        data = request.get_json()
        fabric_name = data.get('fabric_name', '').lower()
        fabric_info = data.get('fabric_info', {})
        
        if not fabric_name or not fabric_info:
            return jsonify({'error': 'Fabric name and info are required'}), 400
        
        return jsonify({
            'success': True,
            'message': f'Fabric info for {fabric_name} updated. Use the full KB update endpoint for permanent changes.'
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/users', methods=['GET'])
@require_admin
def list_users():
    """List all users (admin only)."""
    try:
        users = User.query.all()
        return jsonify({
            'success': True,
            'users': [user.to_dict() for user in users]
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/users/<int:user_id>/admin', methods=['PUT'])
@require_admin
def toggle_admin(user_id):
    """Toggle admin status for a user. Superadmins cannot have admin removed."""
    try:
        user = User.query.get(user_id)
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        data = request.get_json()
        is_admin = data.get('is_admin', False)
        
        # Superadmin must remain admin
        if user.is_superadmin and not is_admin:
            return jsonify({'error': 'Cannot remove admin status from a superadmin'}), 400
        
        user.is_admin = is_admin
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Admin status updated for {user.email}',
            'user': user.to_dict()
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/payment-logs', methods=['GET'])
@require_admin
def get_payment_logs():
    """Get all payment logs (admin only)."""
    try:
        # Get query parameters
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        status = request.args.get('status', None)
        payment_method = request.args.get('payment_method', None)
        user_id = request.args.get('user_id', None, type=int)
        
        # Build query
        query = PaymentLog.query
        
        if status:
            query = query.filter_by(status=status)
        if payment_method:
            query = query.filter_by(payment_method=payment_method)
        if user_id:
            query = query.filter_by(user_id=user_id)
        
        # Get total count
        total = query.count()
        
        # Paginate
        logs = query.order_by(PaymentLog.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Get related orders and users for additional context
        logs_data = []
        for log in logs.items:
            log_dict = log.to_dict()
            if log.order_id:
                order = Order.query.get(log.order_id)
                if order:
                    log_dict['order'] = {
                        'id': order.id,
                        'order_number': order.order_number,
                        'total': float(order.total),
                        'status': order.status
                    }
            if log.user_id:
                user = User.query.get(log.user_id)
                if user:
                    log_dict['user'] = {
                        'id': user.id,
                        'email': user.email
                    }
            logs_data.append(log_dict)
        
        return jsonify({
            'success': True,
            'payment_logs': logs_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': logs.pages
            },
            'summary': {
                'total_logs': total,
                'completed': PaymentLog.query.filter_by(status='completed').count(),
                'failed': PaymentLog.query.filter_by(status='failed').count(),
                'pending': PaymentLog.query.filter_by(status='pending').count()
            }
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/payment-logs/<int:log_id>', methods=['GET'])
@require_admin
def get_payment_log_detail(log_id):
    """Get detailed information about a specific payment log."""
    try:
        log = PaymentLog.query.get_or_404(log_id)
        log_dict = log.to_dict()
        
        # Add related information
        if log.order_id:
            order = Order.query.get(log.order_id)
            if order:
                log_dict['order'] = order.to_dict()
        
        if log.user_id:
            user = User.query.get(log.user_id)
            if user:
                log_dict['user'] = user.to_dict()
        
        return jsonify({
            'success': True,
            'payment_log': log_dict
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ==================== PRODUCT MANAGEMENT ROUTES ====================

@admin_bp.route('/products', methods=['GET'])
@require_admin
def list_products():
    """List all products (including inactive) for admin."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        category = request.args.get('category', None)
        search = request.args.get('search', None)
        
        query = Product.query
        
        if category:
            query = query.filter_by(category=category)
        
        if search:
            from sqlalchemy import or_
            query = query.filter(
                or_(
                    Product.name.ilike(f'%{search}%'),
                    Product.description.ilike(f'%{search}%')
                )
            )
        
        pagination = query.order_by(Product.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        return jsonify({
            'success': True,
            'products': [p.to_dict() for p in pagination.items],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/products/<int:product_id>', methods=['GET'])
@require_admin
def get_product(product_id):
    """Get a single product by ID (admin only, includes inactive)."""
    try:
        product = Product.query.get(product_id)
        if not product:
            return jsonify({'error': 'Product not found'}), 404
        
        return jsonify({
            'success': True,
            'product': product.to_dict()
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/products', methods=['POST'])
@require_admin
def create_product():
    """Create a new product."""
    try:
        data = request.get_json() or {}
        errors = []

        # Required: name
        name = (data.get('name') or '').strip()
        if not name:
            errors.append('Product name is required.')
        elif len(name) > 255:
            errors.append('Product name must be 255 characters or less.')

        # Required: price (valid number, >= 0)
        price_val = data.get('price')
        if price_val is None or price_val == '':
            errors.append('Price is required.')
        else:
            try:
                p = float(price_val)
                if p < 0:
                    errors.append('Price must be zero or greater.')
            except (TypeError, ValueError):
                errors.append('Price must be a valid number (e.g. 29.99).')

        # Required: category
        category = (data.get('category') or '').strip().lower()
        if not category:
            errors.append('Category is required.')
        elif category not in ('men', 'women', 'kids'):
            errors.append('Category must be Men, Women, or Kids.')

        # Optional: stock_quantity (must be int >= 0)
        try:
            sq = data.get('stock_quantity', 0)
            stock_quantity = int(sq) if sq not in (None, '') else 0
            if stock_quantity < 0:
                errors.append('Stock quantity must be zero or greater.')
        except (TypeError, ValueError):
            errors.append('Stock quantity must be a whole number.')

        if errors:
            return jsonify({'error': ' '.join(errors), 'errors': errors}), 400

        price = float(price_val)
        # stock_quantity already set in validation block above

        # Parse available_colors and available_sizes
        available_colors = data.get('available_colors', [])
        available_sizes = data.get('available_sizes', [])
        
        # Convert to JSON strings if they're lists
        if isinstance(available_colors, list):
            available_colors = json.dumps(available_colors) if available_colors else None
        if isinstance(available_sizes, list):
            available_sizes = json.dumps(available_sizes) if available_sizes else None
        
        product = Product(
            name=name,
            description=data.get('description') or None,
            price=price,
            category=category,
            color=data.get('color'),
            size=data.get('size'),
            available_colors=available_colors,
            available_sizes=available_sizes,
            fabric=data.get('fabric'),
            clothing_type=data.get('clothing_type'),
            clothing_category=data.get('clothing_category') or 'other',
            dress_style=data.get('dress_style'),
            occasion=data.get('occasion'),
            age_group=data.get('age_group'),
            season=data.get('season') or 'all_season',
            image_url=data.get('image_url') or None,
            stock_quantity=stock_quantity,
            is_active=data.get('is_active', True),
            rating=float(data.get('rating', 0.0)),
            review_count=int(data.get('review_count', 0)),
            slug=data.get('slug'),
            meta_title=data.get('meta_title'),
            meta_description=data.get('meta_description')
        )
        
        db.session.add(product)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Product created successfully',
            'product': product.to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/products/<int:product_id>', methods=['PUT'])
@require_admin
def update_product(product_id):
    """Update an existing product."""
    try:
        product = Product.query.get(product_id)
        if not product:
            return jsonify({'error': 'Product not found'}), 404
        
        data = request.get_json()
        
        # Update fields
        if 'name' in data:
            product.name = data['name']
        if 'description' in data:
            product.description = data.get('description')
        if 'price' in data:
            product.price = float(data['price'])
        if 'category' in data:
            product.category = data['category']
        if 'color' in data:
            product.color = data.get('color')
        if 'size' in data:
            product.size = data.get('size')
        if 'available_colors' in data:
            colors = data['available_colors']
            if isinstance(colors, list):
                product.available_colors = json.dumps(colors) if colors else None
            else:
                product.available_colors = colors
        if 'available_sizes' in data:
            sizes = data['available_sizes']
            if isinstance(sizes, list):
                product.available_sizes = json.dumps(sizes) if sizes else None
            else:
                product.available_sizes = sizes
        if 'fabric' in data:
            product.fabric = data.get('fabric')
        if 'clothing_type' in data:
            product.clothing_type = data.get('clothing_type')
        if 'clothing_category' in data:
            product.clothing_category = data.get('clothing_category') or 'other'
        if 'dress_style' in data:
            product.dress_style = data.get('dress_style')
        if 'occasion' in data:
            product.occasion = data.get('occasion')
        if 'age_group' in data:
            product.age_group = data.get('age_group')
        if 'season' in data:
            product.season = data.get('season') or 'all_season'
        if 'image_url' in data:
            product.image_url = data.get('image_url')
        if 'stock_quantity' in data:
            product.stock_quantity = int(data.get('stock_quantity', 0))
        if 'is_active' in data:
            product.is_active = bool(data.get('is_active', True))
        if 'rating' in data:
            product.rating = float(data.get('rating', 0.0))
        if 'review_count' in data:
            product.review_count = int(data.get('review_count', 0))
        if 'slug' in data:
            product.slug = data.get('slug')
        if 'meta_title' in data:
            product.meta_title = data.get('meta_title')
        if 'meta_description' in data:
            product.meta_description = data.get('meta_description')
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Product updated successfully',
            'product': product.to_dict()
        }), 200
        
    except Exception as e:
        db.session.rollback()
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/products/<int:product_id>', methods=['DELETE'])
@require_admin
def delete_product(product_id):
    """Delete a product (soft delete by setting is_active=False)."""
    try:
        product = Product.query.get(product_id)
        if not product:
            return jsonify({'error': 'Product not found'}), 404
        
        # Soft delete - set is_active to False
        product.is_active = False
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Product deleted successfully (deactivated)'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# ==================== ORDER MANAGEMENT ROUTES ====================

@admin_bp.route('/orders', methods=['GET'])
@require_admin
def list_orders():
    """List all orders (admin only)."""
    try:
        from sqlalchemy import or_
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        status = request.args.get('status', None)
        user_id = request.args.get('user_id', None, type=int)
        search = request.args.get('search', None)
        
        query = Order.query
        
        if status:
            query = query.filter_by(status=status)
        if user_id:
            query = query.filter_by(user_id=user_id)
        if search:
            query = query.filter(
                or_(
                    Order.order_number.ilike(f'%{search}%'),
                    Order.shipping_name.ilike(f'%{search}%'),
                    Order.guest_email.ilike(f'%{search}%')
                )
            )
        
        pagination = query.order_by(Order.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        return jsonify({
            'success': True,
            'orders': [order.to_dict() for order in pagination.items],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/orders/<int:order_id>', methods=['GET'])
@require_admin
def get_order_admin(order_id):
    """Get a single order (admin only)."""
    try:
        order = Order.query.get_or_404(order_id)
        return jsonify({
            'success': True,
            'order': order.to_dict()
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/orders/<int:order_id>/status', methods=['PUT'])
@require_admin
def update_order_status(order_id):
    """Update order status (admin only)."""
    try:
        order = Order.query.get_or_404(order_id)
        data = request.get_json()
        
        new_status = data.get('status')
        if not new_status:
            return jsonify({'error': 'Status is required'}), 400
        
        valid_statuses = ['pending', 'processing', 'shipped', 'delivered', 'cancelled']
        if new_status not in valid_statuses:
            return jsonify({'error': f'Invalid status. Must be one of: {", ".join(valid_statuses)}'}), 400
        
        order.status = new_status
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Order status updated to {new_status}',
            'order': order.to_dict()
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# ==================== ENHANCED USER MANAGEMENT ROUTES ====================

@admin_bp.route('/users/<int:user_id>', methods=['GET'])
@require_admin
def get_user_details(user_id):
    """Get user details (admin only)."""
    try:
        user = User.query.get_or_404(user_id)
        user_dict = user.to_dict()
        
        # Add additional admin info
        from models.order import Order
        from models.cart import CartItem
        user_dict['order_count'] = Order.query.filter_by(user_id=user_id).count()
        user_dict['cart_item_count'] = CartItem.query.filter_by(user_id=user_id).count()
        
        return jsonify({
            'success': True,
            'user': user_dict
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/users/<int:user_id>', methods=['DELETE'])
@require_admin
def delete_user(user_id):
    """Delete a user (admin only)."""
    try:
        user = User.query.get_or_404(user_id)
        
        # Prevent deleting superadmin
        if user.is_superadmin:
            return jsonify({'error': 'Cannot delete superadmin user'}), 400
        
        # Delete related data (cascade will handle most)
        from models.cart import CartItem
        CartItem.query.filter_by(user_id=user_id).delete()
        
        db.session.delete(user)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'User {user.email} deleted successfully'
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/users/<int:user_id>/password', methods=['PUT'])
@require_admin
def reset_user_password(user_id):
    """Reset user password (admin only)."""
    try:
        user = User.query.get_or_404(user_id)
        data = request.get_json()
        
        new_password = data.get('new_password')
        if not new_password or len(new_password) < 6:
            return jsonify({'error': 'New password must be at least 6 characters'}), 400
        
        import bcrypt
        user.password_hash = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Password reset for {user.email}'
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# ==================== DATABASE STATISTICS ROUTES ====================

@admin_bp.route('/statistics', methods=['GET'])
@require_admin
def get_statistics():
    """Get database statistics (admin only)."""
    from sqlalchemy import func
    from datetime import datetime, timedelta, time

    def _today_start():
        """Start of today in UTC for DateTime comparison."""
        return datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)

    def _safe_scalar(q):
        try:
            return float(q.scalar() or 0)
        except Exception:
            return 0.0

    stats = {}

    # Users
    try:
        stats['users'] = {
            'total': User.query.count(),
            'admins': User.query.filter_by(is_admin=True).count(),
            'superadmins': User.query.filter_by(is_superadmin=True).count(),
            'active': User.query.filter_by(is_verified=True).count()
        }
    except Exception as e:
        stats['users'] = {'total': 0, 'admins': 0, 'superadmins': 0, 'active': 0}

    # Products
    try:
        stats['products'] = {
            'total': Product.query.count(),
            'active': Product.query.filter_by(is_active=True).count(),
            'inactive': Product.query.filter_by(is_active=False).count(),
            'low_stock': Product.query.filter(Product.stock_quantity < 10).count(),
            'out_of_stock': Product.query.filter(Product.stock_quantity == 0).count()
        }
    except Exception:
        stats['products'] = {'total': 0, 'active': 0, 'inactive': 0, 'low_stock': 0, 'out_of_stock': 0}

    # Orders (use datetime for created_at comparison)
    try:
        today_start = _today_start()
        week_ago = datetime.utcnow() - timedelta(days=7)
        month_ago = datetime.utcnow() - timedelta(days=30)
        stats['orders'] = {
            'total': Order.query.count(),
            'pending': Order.query.filter_by(status='pending').count(),
            'processing': Order.query.filter_by(status='processing').count(),
            'shipped': Order.query.filter_by(status='shipped').count(),
            'delivered': Order.query.filter_by(status='delivered').count(),
            'cancelled': Order.query.filter_by(status='cancelled').count(),
            'today': Order.query.filter(Order.created_at >= today_start).count(),
            'this_week': Order.query.filter(Order.created_at >= week_ago).count(),
            'this_month': Order.query.filter(Order.created_at >= month_ago).count()
        }
    except Exception:
        stats['orders'] = {
            'total': 0, 'pending': 0, 'processing': 0, 'shipped': 0, 'delivered': 0,
            'cancelled': 0, 'today': 0, 'this_week': 0, 'this_month': 0
        }

    # Sales (table may not exist in some setups)
    try:
        stats['sales'] = {
            'total': Sale.query.count(),
            'active': Sale.query.filter_by(is_active=True).count(),
            'inactive': Sale.query.filter_by(is_active=False).count()
        }
    except Exception:
        stats['sales'] = {'total': 0, 'active': 0, 'inactive': 0}

    # Reviews
    try:
        today_start = _today_start()
        stats['reviews'] = {
            'total': Review.query.count(),
            'today': Review.query.filter(Review.created_at >= today_start).count()
        }
    except Exception:
        stats['reviews'] = {'total': 0, 'today': 0}

    # Revenue
    try:
        today_start = _today_start()
        week_ago = datetime.utcnow() - timedelta(days=7)
        month_ago = datetime.utcnow() - timedelta(days=30)
        stats['revenue'] = {
            'total': _safe_scalar(db.session.query(func.sum(Order.total))),
            'today': _safe_scalar(db.session.query(func.sum(Order.total)).filter(Order.created_at >= today_start)),
            'this_week': _safe_scalar(db.session.query(func.sum(Order.total)).filter(Order.created_at >= week_ago)),
            'this_month': _safe_scalar(db.session.query(func.sum(Order.total)).filter(Order.created_at >= month_ago))
        }
    except Exception:
        stats['revenue'] = {'total': 0.0, 'today': 0.0, 'this_week': 0.0, 'this_month': 0.0}

    return jsonify({
        'success': True,
        'statistics': stats
    }), 200

# ==================== CART MANAGEMENT ROUTES ====================

@admin_bp.route('/carts', methods=['GET'])
@require_admin
def list_carts():
    """List all user carts (admin only)."""
    try:
        from models.cart import CartItem
        from sqlalchemy import func
        
        # Get carts with item counts and totals
        # Use product.to_dict() to get sale prices if applicable
        carts_query = db.session.query(
            CartItem.user_id,
            func.count(CartItem.id).label('item_count')
        ).group_by(CartItem.user_id).all()
        
        carts_data = []
        for cart in carts_query:
            user = User.query.get(cart.user_id)
            if user:
                # Calculate total using sale prices
                cart_items = CartItem.query.filter_by(user_id=cart.user_id).all()
                total = 0.0
                for item in cart_items:
                    if item.product:
                        try:
                            product_dict = item.product.to_dict()
                            current_price = product_dict.get('price', float(item.product.price) if item.product.price else 0.0)
                        except Exception:
                            current_price = float(item.product.price) if item.product.price else 0.0
                        total += current_price * item.quantity
                
                carts_data.append({
                    'user_id': cart.user_id,
                    'user_email': user.email,
                    'item_count': cart.item_count,
                    'estimated_total': total
                })
        
        return jsonify({
            'success': True,
            'carts': carts_data,
            'count': len(carts_data)
        }), 200
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/carts/user/<int:user_id>', methods=['GET'])
@require_admin
def get_user_cart(user_id):
    """Get a specific user's cart (admin only)."""
    try:
        from models.cart import CartItem
        cart_items = CartItem.query.filter_by(user_id=user_id).all()
        
        return jsonify({
            'success': True,
            'cart_items': [item.to_dict() for item in cart_items]
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/carts/user/<int:user_id>', methods=['DELETE'])
@require_admin
def clear_user_cart(user_id):
    """Clear a user's cart (admin only)."""
    try:
        from models.cart import CartItem
        CartItem.query.filter_by(user_id=user_id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Cart cleared for user {user_id}'
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# ==================== REVIEW MANAGEMENT ROUTES ====================

@admin_bp.route('/reviews', methods=['GET'])
@require_admin
def list_reviews():
    """List all reviews (admin only)."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)
        product_id = request.args.get('product_id', None, type=int)
        user_id = request.args.get('user_id', None, type=int)
        
        query = Review.query
        
        if product_id:
            query = query.filter_by(product_id=product_id)
        if user_id:
            query = query.filter_by(user_id=user_id)
        
        pagination = query.order_by(Review.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Get related product and user info
        reviews_data = []
        for review in pagination.items:
            review_dict = review.to_dict()
            if review.product:
                review_dict['product'] = {
                    'id': review.product.id,
                    'name': review.product.name
                }
            reviews_data.append(review_dict)
        
        return jsonify({
            'success': True,
            'reviews': reviews_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages
            }
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@admin_bp.route('/reviews/<int:review_id>', methods=['DELETE'])
@require_admin
def delete_review_admin(review_id):
    """Delete a review (admin only)."""
    try:
        review = Review.query.get(review_id)
        if not review:
            return jsonify({'error': 'Review not found'}), 404
        
        product_id = review.product_id
        db.session.delete(review)
        db.session.commit()
        
        # Update product rating
        from routes.reviews import update_product_rating
        update_product_rating(product_id)
        
        return jsonify({
            'success': True,
            'message': 'Review deleted successfully'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


# ==================== AI ASSISTANT: 4 FIXED PROVIDERS ====================

from models.ai_assistant_config import (
    AiAssistantConfig,
    AISelectedProvider,
    FIXED_PROVIDERS,
    PROVIDER_DISPLAY_NAMES,
    PROVIDER_SDK,
)
from config import Config


def _sdk_installed_backend(provider):
    """Return True if the backend has the SDK/package for this provider installed."""
    try:
        if provider == 'openai':
            import openai
            return True
        if provider == 'gemini':
            import google.generativeai
            return True
        if provider == 'anthropic':
            import anthropic
            return True
        if provider == 'bedrock':
            import boto3
            return True
    except Exception:
        pass
    return False


def _ensure_four_providers():
    """Ensure exactly 4 rows exist (one per provider). Return list of configs in fixed order."""
    for p in FIXED_PROVIDERS:
        c = AiAssistantConfig.query.filter_by(provider=p).first()
        if not c:
            c = AiAssistantConfig(
                provider=p,
                name=PROVIDER_DISPLAY_NAMES.get(p, p),
                sdk=PROVIDER_SDK.get(p, 'REST API'),
                source='env',
            )
            db.session.add(c)
    db.session.commit()
    return [AiAssistantConfig.query.filter_by(provider=p).first() for p in FIXED_PROVIDERS]


def _provider_dict(c):
    """Build dict for one provider, including source (admin vs env), masked key, and SDK installed status."""
    from routes.ai_agent import get_effective_api_key_for_provider
    effective_key, source = get_effective_api_key_for_provider(c.provider)
    d = c.to_dict(mask_secrets=True)
    d['source'] = source
    d['api_key_display'] = '••••••••' if effective_key else ('' if source == 'env' else '')
    d['sdk_installed_backend'] = _sdk_installed_backend(c.provider)
    return d


@admin_bp.route('/ai-assistant/providers', methods=['GET'])
@require_admin
def list_ai_providers():
    """List the 4 fixed providers (OpenAI, Gemini, Anthropic, Bedrock) with key status and selected provider."""
    try:
        configs = _ensure_four_providers()
        # Always return exactly 4 rows (one per fixed provider); build placeholder if any config missing
        providers_list = []
        for i, p in enumerate(FIXED_PROVIDERS):
            c = configs[i] if i < len(configs) else None
            if not c:
                c = AiAssistantConfig(
                    provider=p,
                    name=PROVIDER_DISPLAY_NAMES.get(p, p),
                    sdk=PROVIDER_SDK.get(p, 'REST API'),
                    source='env',
                )
                c.is_valid = False
                c.last_tested_at = None
            providers_list.append(_provider_dict(c))
        row = AISelectedProvider.query.first()
        selected = (row.provider if row else 'auto')
        if not row:
            row = AISelectedProvider(id=1, provider='auto')
            db.session.add(row)
            db.session.commit()
            selected = 'auto'
        return jsonify({
            'success': True,
            'providers': providers_list,
            'selected_provider': selected,
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@admin_bp.route('/ai-assistant/providers/<provider>', methods=['PATCH'])
@require_admin
def patch_ai_provider(provider):
    """Update API key (and optional model_id) for one of the 4 providers. Sets source to admin."""
    if provider not in FIXED_PROVIDERS:
        return jsonify({'error': 'Invalid provider'}), 400
    try:
        config = AiAssistantConfig.query.filter_by(provider=provider).first()
        if not config:
            config = AiAssistantConfig(provider=provider, name=PROVIDER_DISPLAY_NAMES.get(provider), sdk=PROVIDER_SDK.get(provider), source='admin')
            db.session.add(config)
        data = request.get_json() or {}
        if 'api_key' in data:
            val = (data.get('api_key') or '').strip()
            config.api_key = val if val else None
            config.source = 'admin' if config.api_key else 'env'
        if 'model_id' in data:
            config.model_id = (data.get('model_id') or '').strip() or None
        if 'region' in data and provider == 'bedrock':
            config.region = (data.get('region') or '').strip() or None
        db.session.commit()
        return jsonify({
            'success': True,
            'message': 'Provider updated',
            'provider': _provider_dict(config),
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@admin_bp.route('/ai-assistant/providers/<provider>/test', methods=['POST'])
@require_admin
def test_ai_provider(provider):
    """Test API key for this provider; set is_valid, last_tested_at, latency_ms."""
    if provider not in FIXED_PROVIDERS:
        return jsonify({'error': 'Invalid provider'}), 400
    try:
        from routes.ai_agent import test_provider_latency
        config = AiAssistantConfig.query.filter_by(provider=provider).first()
        if not config:
            config = AiAssistantConfig(provider=provider, name=PROVIDER_DISPLAY_NAMES.get(provider), sdk=PROVIDER_SDK.get(provider), source='env')
            db.session.add(config)
            db.session.commit()
        latency_ms, err = test_provider_latency(provider)
        from datetime import datetime
        config.last_tested_at = datetime.utcnow()
        config.latency_ms = latency_ms
        config.is_valid = err is None
        db.session.commit()
        if err:
            return jsonify({'success': False, 'error': err, 'provider': _provider_dict(config)}), 400
        return jsonify({
            'success': True,
            'latency_ms': latency_ms,
            'message': f'Valid — {latency_ms} ms',
            'provider': _provider_dict(config),
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@admin_bp.route('/ai-assistant/selected-provider', methods=['GET'])
@require_admin
def get_selected_provider():
    try:
        row = AISelectedProvider.query.first()
        return jsonify({
            'success': True,
            'selected_provider': row.provider if row else 'auto',
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@admin_bp.route('/ai-assistant/selected-provider', methods=['PUT'])
@require_admin
def put_selected_provider():
    """Set default model: auto | openai | gemini | anthropic | bedrock."""
    try:
        data = request.get_json() or {}
        provider = (data.get('provider') or data.get('selected_provider') or 'auto').strip().lower()
        if provider not in ('auto',) + FIXED_PROVIDERS:
            return jsonify({'error': 'Provider must be auto, openai, gemini, anthropic, or bedrock'}), 400
        row = AISelectedProvider.query.first()
        if not row:
            row = AISelectedProvider(id=1, provider=provider)
            db.session.add(row)
        else:
            row.provider = provider
        db.session.commit()
        return jsonify({
            'success': True,
            'selected_provider': row.provider,
        }), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

